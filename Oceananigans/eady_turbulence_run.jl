# # Eady turbulence example
#
# In this example, we initialize a random velocity field and observe its viscous,
# turbulent decay in a two-dimensional domain. This example demonstrates:
#
#   * How to use a tuple of turbulence closures
#   * How to use biharmonic diffusivity
#   * How to implement background velocity and tracer distributions
#   * How to create `ComputedField`s for output
#
# # The Eady problem 
#
# The "Eady problem" simulates the baroclinic instability problem proposed by Eric Eady in
# his classic paper
# ["Long waves and cyclone waves," Tellus (1949)](https://www.tandfonline.com/doi/abs/10.3402/tellusa.v1i3.8507).
# The Eady problem is a simple, canonical model for the generation of mid-latitude
# atmospheric storms and the ocean eddies that permeate the world sea.
#
# In the Eady problem, baroclinic motion and turublence is generated by the interaction
# between turbulent motions and a stationary, geostrophically-balanced basic state that
# is unstable to baroclinic instability. In this example, the baroclinic generation of
# turbulence due to extraction of energy from the geostrophic basic state
# is balanced by a bottom boundary condition that extracts momentum from turbulent motions
# and serves as a crude model for the drag associated with an unresolved and small-scale
# turbulent bottom boundary layer.
# 
# ## The geostrophic basic state
#
# The geostrophic basic state in the Eady problem is represented by the streamfunction,
#
# $ ψ(y, z) = - α f y (z + L_z) $,
#
# where $f$ is the Coriolis parameter, $α$ is the geostrophic shear
# and horizontal buoyancy gradient, and $L_z$ is the depth of the domain.
# The background buoyancy, including both the geostrophic flow component
# and a background stable stratification component, is
#
# $ B = B'(y) + N^2 z = f ∂_z ψ + N^2 z = - α f y + N^2 z$
#
# The background velocity field is
#
# $ U(z) = - ∂_y ψ = α (z + L_z) $
#
# ## Quadratic bottom drag
#
# In this example, we model the presence of a turbulent bottom boundary layer
# with a quadratic bottom drag that fluxes momentum out of the domain.
# For example, the $x$-component of the bottom drag, which acts on the $u$-velocity, is
#
# $ Q_u = - c^D \sqrt(u^2 + v^2) u \, ,$
#
# while the $y$-component is
#
# $ Q_v = - c^D \sqrt(u^2 + v^2) v \, ,$
#
# where $Q_u$ and $Q_v$ denote the flux of $u$ and $v$ momentum and $c^D$ is a
# dimensionless drag coefficient.
#
# ## Vertical and horizontal viscosity and diffusivity
#
# Vertical and horizontal viscosties and diffusivities are generally required
# to stabilize the Eady problem and can be used to model the presence of
# turbulent mixing below the grid scale. For this example, we use the same Laplacian
# vertical diffusivity and a biharmonic horizontal diffusivity for tracers
# and momentum. For a tracer $c$ our diffusion model thus takes the form
#
# $ \Big [ \kappa_{2,z} \partial_z^2 + \kappa_{4,h} \left ( \partial_x^4 + \partial_y^4 \right ) \Big ] c \, .$
#
# ## Eady problem summary and parameters
#
# To summarize, the Eady problem parameters (and the values we use for this example) are
#
# | Parameter name | Description | Value | Units |
# | -------------- | ----------- | ----- | ----- | 
# | $ f $          | Coriolis parameter | $ 10^{-4} $ | $ \mathrm{s^{-1}} $ |
# | $ N $          | Buoyancy frequency (square root of background buoyancy gradient) | $ 5 \times 10^{-3} $ | $ \mathrm{s^{-1}} $ |
# | $ \alpha $     | Background vertical shear / horizontal buoyancy gradient | $ 10^{-3} $ | $ \mathrm{s^{-1}} $ |
# | $ c\^D $       | Bottom drag coefficient | $ 10^{-4} $ | none |
# | $ κ_{2,z} $    | Laplacian vertical diffusivity | $ 10^{-2} $ | $ \mathrm{m^2 s^{-1}} $ |
# | $ κ_{4,h} $    | Biharmonic horizontal diffusivity | $ 10^{-2} \times \Delta x^4 / \mathrm{day} $ | $ \mathrm{m^4 s^{-1}} $ |

# # The grid
#
# We use a three-dimensional grid with a depth of 1000 m and a 
# horizontal extent of 1000 km, appropriate for mesoscale ocean dynamics
# with characteristic scales of 50-200 km.

using Oceananigans

grid = RegularCartesianGrid(size=(256, 256, 64), x=(0, 4e6), y=(0, 4e6), z=(-4e3, 0))

# # Rotation
#
# The classical Eady problem is posed on an $f$-plane. We use a Coriolis parameter
# typical to mid-latitudes on Earth,

coriolis = FPlane(f=1e-4) # [s⁻¹]
                            
# # The background flow
#
# We build a `NamedTuple` of parameters that describe the background flow,

background_parameters = ( α = 0.25 * coriolis.f, # s⁻¹, geostrophic shear
                          f = coriolis.f,        # s⁻¹, Coriolis parameter
                          N = 3.3e-3,            # s⁻¹, buoyancy frequency
                         Lz = grid.Lz)           # m, ocean depth

# and then construct the background fields $U$ and $B$

using Oceananigans.Fields: BackgroundField

## Background fields are defined via functions of x, y, z, t, and optional parameters
U(x, y, z, t, p) = + p.α * (z + p.Lz)
B(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z

U_field = BackgroundField(U, parameters=background_parameters)
B_field = BackgroundField(B, parameters=background_parameters)

# # Boundary conditions
#
# These boundary conditions prescribe a quadratic drag at the bottom as a flux
# condition. We also fix the surface and bottom buoyancy to enforce a buoyancy
# gradient `N²`.

drag_coefficient = 1e-3

@inline drag_u(u, v, cᴰ) = - cᴰ * sqrt(u^2 + v^2) * u
@inline drag_v(u, v, cᴰ) = - cᴰ * sqrt(u^2 + v^2) * v

@inline bottom_drag_u(i, j, grid, clock, f, cᴰ) = @inbounds drag_u(f.u[i, j, 1], f.v[i, j, 1], cᴰ)
@inline bottom_drag_v(i, j, grid, clock, f, cᴰ) = @inbounds drag_v(f.u[i, j, 1], f.v[i, j, 1], cᴰ)
    
drag_bc_u = BoundaryCondition(Flux, bottom_drag_u, discrete_form=true, parameters=drag_coefficient)
drag_bc_v = BoundaryCondition(Flux, bottom_drag_v, discrete_form=true, parameters=drag_coefficient)

u_bcs = UVelocityBoundaryConditions(grid, bottom = drag_bc_u) 
v_bcs = VVelocityBoundaryConditions(grid, bottom = drag_bc_v)

# # Turbulence closures
#
# We use a horizontal biharmonic diffusivity and a Laplacian vertical diffusivity
# to dissipate energy in the Eady problem.
# To use both of these closures at the same time, we set the keyword argument
# `closure` a tuple of two closures.

using Oceananigans.Utils: day

κ₂z = 1e-3 # [m² s⁻¹] Laplacian vertical viscosity and diffusivity
κ₂h = 0.0  # [m² s⁻¹] Laplacian horizontal viscosity and diffusivity
κ₄h = 5e-2 / day * grid.Δx^4 # [m⁴ s⁻¹] biharmonic horizontal viscosity and diffusivity

Laplacian_vertical_diffusivity = AnisotropicDiffusivity(νh=κ₂h, κh=κ₂h, νz=κ₂z, κz=κ₂z)
biharmonic_horizontal_diffusivity = AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)

# # Model instantiation

using Oceananigans.Advection: WENO5

model = IncompressibleModel(
           architecture = GPU(),
                   grid = grid,
              advection = WENO5(),
            timestepper = :RungeKutta3,
               coriolis = coriolis,
                tracers = :b,
               buoyancy = BuoyancyTracer(),
      background_fields = (b=B_field, u=U_field),
                closure = (Laplacian_vertical_diffusivity, biharmonic_horizontal_diffusivity),
    boundary_conditions = (u=u_bcs, v=v_bcs)
)

# # Initial conditions
#
# We use non-trivial initial conditions consisting of an array of vortices superposed
# with large-amplitude noise to (hopefully) stimulate the rapid growth of
# baroclinic instability.

## A noise function, damped at the top and bottom
Ξ(z) = randn() * z/grid.Lz * (z/grid.Lz + 1)

## Scales for the initial velocity and buoyancy
Ũ = 1e-1 * background_parameters.α * grid.Lz
B̃ = 1e-2 * background_parameters.α * coriolis.f

uᵢ(x, y, z) = Ũ * Ξ(z)
vᵢ(x, y, z) = Ũ * Ξ(z)
bᵢ(x, y, z) = B̃ * Ξ(z)

set!(model, u=uᵢ, v=vᵢ, b=bᵢ)

# We subtract off any residual mean velocity to avoid exciting domain-scale
# inertial oscillations. We use a `sum` over the entire `parent` arrays or data
# to ensure this operation is efficient on the GPU (set `architecture = GPU()`
# in `IncompressibleModel` constructor to run this problem on the GPU if one
# is available).

Ū = sum(model.velocities.u.data.parent) / (grid.Nx * grid.Ny * grid.Nz)
V̄ = sum(model.velocities.v.data.parent) / (grid.Nx * grid.Ny * grid.Nz)

model.velocities.u.data.parent .-= Ū
model.velocities.v.data.parent .-= V̄

# # Simulation set-up
#
# We set up a simulation and run it for 10 days.
# We then stop the simulation and add a JLD2OutputWriter that saves the vertical
# velocity, vertical vorticity, and divergence every 2 iterations.
# We then continue the run for 100 iterations and plot the resulting 50 frames of
# saved data in an animation.
#
# ## The `TimeStepWizard`
#
# The TimeStepWizard manages the time-step adaptively, keeping the CFL close to a
# desired value.

using Oceananigans.Utils: minute, hour

## Calculate absolute limit on time-step using diffusivities and 
## background velocity.
Ū = background_parameters.α * grid.Lz

max_Δt = min(hour / 2, grid.Δx / Ū, 0.5 * grid.Δx^4 / κ₄h, 0.5 * grid.Δz^2 / κ₂z)

wizard = TimeStepWizard(cfl=1.0, Δt=0.1*max_Δt, max_change=1.1, max_Δt=max_Δt)

# ## A progress messenger
#
# We write a function that prints out a helpful progress message while the simulation runs.

using Printf
using Oceananigans.Diagnostics: AdvectiveCFL

CFL = AdvectiveCFL(wizard)

start_time = time_ns()

progress(sim) = @printf("i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n",
                        sim.model.clock.iteration,
                        prettytime(sim.model.clock.time),
                        prettytime(1e-9 * (time_ns() - start_time)),
                        prettytime(sim.Δt.Δt),
                        CFL(sim.model))

# ## Build the simulation
#
# We're ready to build and run the simulation. We ask for a progress message and time-step update
# every 100 iterations,

simulation = Simulation(model, Δt = wizard, iteration_interval = 100,
                                                     stop_time = 2 * 365day,
                                                      progress = progress)
# ## Output and plotting
#
# To visualize the baroclinic turbulence ensuing in the Eady problem,
# we use `ComputedField`s to diagnose and output vertical vorticity and divergence.
# Note that `ComputedField`s take "AbstractOperations" on `Field`s as input:

using Oceananigans.AbstractOperations
using Oceananigans.Fields: ComputedField

u, v, w = model.velocities # unpack velocity `Field`s

## Vertical vorticity [s⁻¹]
ζ = ComputedField(∂x(v) - ∂y(u))

## Horizontal divergence, or ∂x(u) + ∂y(v) [s⁻¹]
δ = ComputedField(-∂z(w))

# With the vertical vorticity, `ζ`, and the horizontal divergence, `δ` in hand,
# we create a JLD2OutputWriter that saves `ζ` and `δ` and add it to 
# `simulation`.

using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer
using Oceananigans.Utils: GiB

simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, model.tracers, (ζ=ζ, δ=δ)),
                                                      time_interval = 4day,
                                                             prefix = "eady_turbulence_fields",
                                                       max_filesize = 2GiB,
                                                              force = true)

simulation.output_writers[:surface] = JLD2OutputWriter(model, merge(model.velocities, model.tracers, (ζ=ζ, δ=δ)),
                                                      time_interval = 24hour,
                                                             prefix = "eady_turbulence_surface",
                                                       field_slicer = FieldSlicer(k=grid.Nz),
                                                       max_filesize = 2GiB,
                                                              force = true)

simulation.output_writers[:middepth] = JLD2OutputWriter(model, merge(model.velocities, model.tracers, (ζ=ζ, δ=δ)),
                                                        time_interval = 24hour,
                                                               prefix = "eady_turbulence_middepth",
                                                         field_slicer = FieldSlicer(k=round(Int, grid.Nz/2)),
                                                         max_filesize = 2GiB,
                                                                force = true)

simulation.output_writers[:bottom] = JLD2OutputWriter(model, merge(model.velocities, model.tracers, (ζ=ζ, δ=δ)),
                                                      time_interval = 24hour,
                                                             prefix = "eady_turbulence_bottom",
                                                       field_slicer = FieldSlicer(k=2),
                                                       max_filesize = 2GiB,
                                                              force = true)

simulation.output_writers[:slice_xz] = JLD2OutputWriter(model, merge(model.velocities, model.tracers, (ζ=ζ, δ=δ)),
                                                        time_interval = 24hour,
                                                               prefix = "eady_turbulence_xzslices",
                                                         field_slicer = FieldSlicer(j=2),
                                                         max_filesize = 2GiB,
                                                                force = true)

simulation.output_writers[:slice_xy] = JLD2OutputWriter(model, merge(model.velocities, model.tracers, (ζ=ζ, δ=δ)),
                                                        time_interval = 24hour,
                                                               prefix = "eady_turbulence_xyslices",
                                                         field_slicer = FieldSlicer(i=2),
                                                         max_filesize = 2GiB,
                                                                force = true)

# Press the big red button:

run!(simulation)
