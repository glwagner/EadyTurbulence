# # Eady turbulence example
#
# In this example, we initialize a random velocity field and observe its viscous,
# turbulent decay in a two-dimensional domain. This example demonstrates:
#
#   * How to use a tuple of turbulence closures
#   * How to use biharmonic diffusivity
#   * How to implement background velocity and tracer distributions
#   * How to create `ComputedField`s for output
#
# # The Eady problem 
#
# The "Eady problem" simulates the baroclinic instability problem proposed by Eric Eady in
# his classic paper
# ["Long waves and cyclone waves," Tellus (1949)](https://www.tandfonline.com/doi/abs/10.3402/tellusa.v1i3.8507).
# The Eady problem is a simple, canonical model for the generation of mid-latitude
# atmospheric storms and the ocean eddies that permeate the world sea.
#
# In the Eady problem, baroclinic motion and turublence is generated by the interaction
# between turbulent motions and a stationary, geostrophically-balanced basic state that
# is unstable to baroclinic instability. In this example, the baroclinic generation of
# turbulence due to extraction of energy from the geostrophic basic state
# is balanced by a bottom boundary condition that extracts momentum from turbulent motions
# and serves as a crude model for the drag associated with an unresolved and small-scale
# turbulent bottom boundary layer.
# 
# ## The geostrophic basic state
#
# The geostrophic basic state in the Eady problem is represented by the streamfunction,
#
# $ ψ(y, z) = - α f y (z + L_z) $,
#
# where $f$ is the Coriolis parameter, $α$ is the geostrophic shear
# and horizontal buoyancy gradient, and $L_z$ is the depth of the domain.
# The background buoyancy, including both the geostrophic flow component
# and a background stable stratification component, is
#
# $ B = B'(y) + N^2 z = f ∂_z ψ + N^2 z = - α f y + N^2 z$
#
# The background velocity field is
#
# $ U(z) = - ∂_y ψ = α (z + L_z) $
#
# ## Quadratic bottom drag
#
# In this example, we model the presence of a turbulent bottom boundary layer
# with a quadratic bottom drag that fluxes momentum out of the domain.
# For example, the $x$-component of the bottom drag, which acts on the $u$-velocity, is
#
# $ Q_u = - c^D \sqrt(u^2 + v^2) u \, ,$
#
# while the $y$-component is
#
# $ Q_v = - c^D \sqrt(u^2 + v^2) v \, ,$
#
# where $Q_u$ and $Q_v$ denote the flux of $u$ and $v$ momentum and $c^D$ is a
# dimensionless drag coefficient.
#
# ## Vertical and horizontal viscosity and diffusivity
#
# Vertical and horizontal viscosties and diffusivities are generally required
# to stabilize the Eady problem and can be used to model the presence of
# turbulent mixing below the grid scale. For this example, we use the same Laplacian
# vertical diffusivity and a biharmonic horizontal diffusivity for tracers
# and momentum. For a tracer $c$ our diffusion model thus takes the form
#
# $ \Big [ \kappa_{2,z} \partial_z^2 + \kappa_{4,h} \left ( \partial_x^4 + \partial_y^4 \right ) \Big ] c \, .$
#
# ## Eady problem summary and parameters
#
# To summarize, the Eady problem parameters (and the values we use for this example) are
#
# | Parameter name | Description | Value | Units |
# | -------------- | ----------- | ----- | ----- | 
# | $ f $          | Coriolis parameter | $ 10^{-4} $ | $ \mathrm{s^{-1}} $ |
# | $ N $          | Buoyancy frequency (square root of background buoyancy gradient) | $ 5 \times 10^{-3} $ | $ \mathrm{s^{-1}} $ |
# | $ \alpha $     | Background vertical shear / horizontal buoyancy gradient | $ 10^{-3} $ | $ \mathrm{s^{-1}} $ |
# | $ c\^D $       | Bottom drag coefficient | $ 10^{-4} $ | none |
# | $ κ_{2,z} $    | Laplacian vertical diffusivity | $ 10^{-2} $ | $ \mathrm{m^2 s^{-1}} $ |
# | $ κ_{4,h} $    | Biharmonic horizontal diffusivity | $ 10^{-2} \times \Delta x^4 / \mathrm{day} $ | $ \mathrm{m^4 s^{-1}} $ |

# # The grid
#
# We use a three-dimensional grid with a depth of 1000 m and a 
# horizontal extent of 1000 km, appropriate for mesoscale ocean dynamics
# with characteristic scales of 50-200 km.

using Oceananigans

grid = RegularCartesianGrid(size=(48, 48, 16), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0))

# # Rotation
#
# The classical Eady problem is posed on an $f$-plane. We use a Coriolis parameter
# typical to mid-latitudes on Earth,

coriolis = FPlane(f=1e-4) # [s⁻¹]
                            
# # The background flow
#
# We build a `NamedTuple` of parameters that describe the background flow,

background_parameters = ( α = 10 * coriolis.f, # s⁻¹, geostrophic shear
                          f = coriolis.f,      # s⁻¹, Coriolis parameter
                          N = 1e-3,            # s⁻¹, buoyancy frequency
                         Lz = grid.Lz)         # m, ocean depth

# and then construct the background fields $U$ and $B$

using Oceananigans.Fields: BackgroundField

## Background fields are defined via functions of x, y, z, t, and optional parameters
U(x, y, z, t, p) = + p.α * (z + p.Lz)
B(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z

U_field = BackgroundField(U, parameters=background_parameters)
B_field = BackgroundField(B, parameters=background_parameters)

# # Boundary conditions
#
# These boundary conditions prescribe a quadratic drag at the bottom as a flux
# condition. We also fix the surface and bottom buoyancy to enforce a buoyancy
# gradient `N²`.

drag_coefficient = 1e-4

@inline drag_u(u, v, cᴰ) = - cᴰ * sqrt(u^2 + v^2) * u
@inline drag_v(u, v, cᴰ) = - cᴰ * sqrt(u^2 + v^2) * v

@inline bottom_drag_u(i, j, grid, clock, f, cᴰ) = @inbounds drag_u(f.u[i, j, 1], f.v[i, j, 1], cᴰ)
@inline bottom_drag_v(i, j, grid, clock, f, cᴰ) = @inbounds drag_v(f.u[i, j, 1], f.v[i, j, 1], cᴰ)
    
drag_bc_u = BoundaryCondition(Flux, bottom_drag_u, discrete_form=true, parameters=drag_coefficient)
drag_bc_v = BoundaryCondition(Flux, bottom_drag_v, discrete_form=true, parameters=drag_coefficient)

u_bcs = UVelocityBoundaryConditions(grid, bottom = drag_bc_u) 
v_bcs = VVelocityBoundaryConditions(grid, bottom = drag_bc_v)

# # Turbulence closures
#
# We use a horizontal biharmonic diffusivity and a Laplacian vertical diffusivity
# to dissipate energy in the Eady problem.
# To use both of these closures at the same time, we set the keyword argument
# `closure` a tuple of two closures.

using Oceananigans.Utils: day

κ₂z = 1e-2 # [m² s⁻¹] Laplacian vertical viscosity and diffusivity
κ₂h = 0.0  # [m² s⁻¹] Laplacian horizontal viscosity and diffusivity
κ₄h = 1e-1 / day * grid.Δx^4 # [m⁴ s⁻¹] biharmonic horizontal viscosity and diffusivity

Laplacian_vertical_diffusivity = AnisotropicDiffusivity(νh=κ₂h, κh=κ₂h, νz=κ₂z, κz=κ₂z)
biharmonic_horizontal_diffusivity = AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)

# # Model instantiation

using Oceananigans.Advection: WENO5

model = IncompressibleModel(
           architecture = CPU(),
                   grid = grid,
              advection = WENO5(),
            timestepper = :RungeKutta3,
               coriolis = coriolis,
                tracers = :b,
               buoyancy = BuoyancyTracer(),
      background_fields = (b=B_field, u=U_field),
                closure = (Laplacian_vertical_diffusivity, biharmonic_horizontal_diffusivity),
    boundary_conditions = (u=u_bcs, v=v_bcs)
)

# # Initial conditions
#
# We use non-trivial initial conditions consisting of an array of vortices superposed
# with large-amplitude noise to (hopefully) stimulate the rapid growth of
# baroclinic instability.

## A noise function, damped at the top and bottom
Ξ(z) = randn() * z/grid.Lz * (z/grid.Lz + 1)

## Scales for the initial velocity and buoyancy
Ũ = 1e-1 * background_parameters.α * grid.Lz
B̃ = 1e-2 * background_parameters.α * coriolis.f

uᵢ(x, y, z) = Ũ * Ξ(z)
vᵢ(x, y, z) = Ũ * Ξ(z)
bᵢ(x, y, z) = B̃ * Ξ(z)

set!(model, u=uᵢ, v=vᵢ, b=bᵢ)

# We subtract off any residual mean velocity to avoid exciting domain-scale
# inertial oscillations. We use a `sum` over the entire `parent` arrays or data
# to ensure this operation is efficient on the GPU (set `architecture = GPU()`
# in `IncompressibleModel` constructor to run this problem on the GPU if one
# is available).

Ū = sum(model.velocities.u.data.parent) / (grid.Nx * grid.Ny * grid.Nz)
V̄ = sum(model.velocities.v.data.parent) / (grid.Nx * grid.Ny * grid.Nz)

model.velocities.u.data.parent .-= Ū
model.velocities.v.data.parent .-= V̄

# # Simulation set-up
#
# We set up a simulation and run it for 10 days.
# We then stop the simulation and add a JLD2OutputWriter that saves the vertical
# velocity, vertical vorticity, and divergence every 2 iterations.
# We then continue the run for 100 iterations and plot the resulting 50 frames of
# saved data in an animation.
#
# ## The `TimeStepWizard`
#
# The TimeStepWizard manages the time-step adaptively, keeping the CFL close to a
# desired value.

using Oceananigans.Utils: minute

## Calculate absolute limit on time-step using diffusivities and 
## background velocity.
Ū = background_parameters.α * grid.Lz

max_Δt = min(grid.Δx / Ū, grid.Δx^4 / κ₄h, grid.Δz^2 / κ₂z)

wizard = TimeStepWizard(cfl=1.0, Δt=0.1*max_Δt, max_change=1.1, max_Δt=max_Δt)

# ## A progress messenger
#
# We write a function that prints out a helpful progress message while the simulation runs.

using Printf
using Oceananigans.Diagnostics: AdvectiveCFL

CFL = AdvectiveCFL(wizard)

start_time = time_ns()

progress(sim) = @printf("i: % 6d, sim time: % 10s, wall time: % 10s, Δt: % 10s, CFL: %.2e\n",
                        sim.model.clock.iteration,
                        prettytime(sim.model.clock.time),
                        prettytime(1e-9 * (time_ns() - start_time)),
                        prettytime(sim.Δt.Δt),
                        CFL(sim.model))

# ## Build the simulation
#
# We're ready to build and run the simulation. We ask for a progress message and time-step update
# every 100 iterations,

simulation = Simulation(model, Δt = wizard, iteration_interval = 10,
                                                     stop_time = 10day,
                                                      progress = progress)

# ## Output and plotting
#
# To visualize the baroclinic turbulence ensuing in the Eady problem,
# we use `ComputedField`s to diagnose and output vertical vorticity and divergence.
# Note that `ComputedField`s take "AbstractOperations" on `Field`s as input:

using Oceananigans.AbstractOperations
using Oceananigans.Fields: ComputedField

u, v, w = model.velocities # unpack velocity `Field`s

## Vertical vorticity [s⁻¹]
ζ = ComputedField(∂x(v) - ∂y(u))

## Horizontal divergence, or ∂x(u) + ∂y(v) [s⁻¹]
δ = ComputedField(-∂z(w))

# With the vertical vorticity, `ζ`, and the horizontal divergence, `δ` in hand,
# we create a JLD2OutputWriter that saves `ζ` and `δ` and add it to 
# `simulation`.

using Oceananigans.OutputWriters: JLD2OutputWriter
using Oceananigans.Utils: hour

simulation.output_writers[:fields] = JLD2OutputWriter(model, (ζ=ζ, δ=δ),
                                                      time_interval = 2hour,
                                                             prefix = "eady_turbulence",
                                                              force = true)

# Press the big red button:

run!(simulation)

# # Visualizing Eady turbulence
#
# We animate the results by opening the JLD2 file, extracting data for
# the iterations we ended up saving at, and ploting slices of the saved
# fields. We prepare for animating the flow by creating coordinate arrays,
# opening the file, building a vector of the iterations that we saved
# data at, and defining a function for computing colorbar limits: 

using JLD2, Plots, Printf, Oceananigans.Grids

using Oceananigans.Grids: x_domain, y_domain, z_domain # for nice domain limits

pyplot() # pyplot backend is a bit nicer than GR

## Coordinate arrays
xζ, yζ, zζ = nodes(ζ)
xδ, yδ, zδ = nodes(δ)

## Open the file with our data
file = jldopen(simulation.output_writers[:fields].filepath)

## Extract a vector of iterations
iterations = parse.(Int, keys(file["timeseries/t"]))

# This utility is handy for calculating nice contour intervals:

function nice_divergent_levels(c, clim, nlevels=30)
    levels = range(-clim, stop=clim, length=10)

    cmax = maximum(abs, c)
    if clim < cmax # add levels on either end
        levels = vcat([-cmax], range(-clim, stop=clim, length=nlevels), [cmax])
    end

    return levels
end

# Now we're ready to animate.

@info "Making an animation from saved data..."

anim = @animate for (i, iter) in enumerate(iterations)

    ## Load 3D fields from file
    t = file["timeseries/t/$iter"]
    R = file["timeseries/ζ/$iter"] ./ coriolis.f
    δ = file["timeseries/δ/$iter"]

    surface_R = R[:, :, grid.Nz]
    surface_δ = δ[:, :, grid.Nz]

    slice_R = R[:, 1, :]
    slice_δ = δ[:, 1, :]

    Rlim = 0.5 * maximum(abs, R) + 1e-9
    δlim = 0.5 * maximum(abs, δ) + 1e-9

    Rlevels = nice_divergent_levels(R, Rlim)
    δlevels = nice_divergent_levels(δ, δlim)

    @info @sprintf("Drawing frame %d from iteration %d: max(ζ̃ / f) = %.3f \n",
                   i, iter, maximum(abs, surface_R))

    R_xy = contourf(xζ, yζ, surface_R';
                          color = :balance,
                    aspectratio = 1,
                         legend = false,
                          clims = (-Rlim, Rlim),
                         levels = Rlevels,
                          xlims = (0, grid.Lx),
                          ylims = (0, grid.Lx),
                         xlabel = "x (m)",
                         ylabel = "y (m)")
    
    δ_xy = contourf(xδ, yδ, surface_δ';
                          color = :balance,
                    aspectratio = 1,
                         legend = false,
                          clims = (-δlim, δlim),
                         levels = δlevels,
                          xlims = (0, grid.Lx),
                          ylims = (0, grid.Lx),
                         xlabel = "x (m)",
                         ylabel = "y (m)")

    R_xz = contourf(xζ, zζ, slice_R';
                    aspectratio = grid.Lx / grid.Lz * 0.5,
                          color = :balance,
                         legend = false,
                          clims = (-Rlim, Rlim),
                         levels = Rlevels,
                          xlims = (0, grid.Lx),
                          ylims = (-grid.Lz, 0),
                         xlabel = "x (m)",
                         ylabel = "z (m)")

    δ_xz = contourf(xδ, zδ, slice_δ';
                    aspectratio = grid.Lx / grid.Lz * 0.5,
                          color = :balance,
                         legend = false,
                          clims = (-δlim, δlim),
                         levels = δlevels,
                          xlims = (0, grid.Lx),
                          ylims = (-grid.Lz, 0),
                         xlabel = "x (m)",
                         ylabel = "z (m)")

    plot(R_xy, δ_xy, R_xz, δ_xz,
           size = (1000, 800),
           link = :x,
         layout = Plots.grid(2, 2, heights=[0.5, 0.5, 0.2, 0.2]),
          title = [@sprintf("ζ/f(t=%s) (s⁻¹)", prettytime(t)) @sprintf("δ(t=%s) (s⁻¹)", prettytime(t)) "" ""])

    iter == iterations[end] && close(file)
end

gif(anim, "eady_turbulence.gif", fps = 8) # hide
